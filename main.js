let main = document.querySelector("main");
let startGameBtn = document.querySelector("#start");
let placeShipsBtn = document.querySelector("#place");
let btnContainer = document.querySelector(".btn_container");
let scorContainer = document.querySelector(".score_container");
let resetBtn = document.querySelector("#reset");
let computerMsg = document.querySelector("#computer");
let playerMsg = document.querySelector("#player");
let winnerMsg = document.querySelector("#winner");
let score1Msg = document.querySelector("#score1");
let score2Msg = document.querySelector("#score2");
let gridCoord = [];
//array for the right edge of the grid to test that values don't fall under those indexes
let righEdge = [9, 19, 29, 39, 49, 59, 69, 79, 89, 99];
//creates an array that simulates the index of the grid in html file
for (i = 0; i < 100; i++) {
  gridCoord.push(i);
}
let makeGameBoard = (id) => {
  let gridContainer = document.createElement("div");
  gridContainer.classList.add("container");
  gridContainer.classList.add(id);
  main.appendChild(gridContainer);
  for (i = 0; i < 100; i++) {
    let gridItems = document.createElement("div");
    gridItems.classList.add("items");
    gridItems.textContent = `${i}`;
    gridContainer.appendChild(gridItems);
    gridItems.parentElement.style.gridTemplateColumns = `repeat(${10}, 1fr)`;
  }
};
let t = 0;
let y = 0;
class Ship {
  constructor(shipArray, shipsSunk, id) {
    (this.shipArray = shipArray), (this.shipsSunk = shipsSunk), (this.id = id);
  }
  createShip(length, rotation) {
    let self = this;
    let tempGridCoord = gridCoord; //to make the grid template modifiable
    let increment;
    let ship = [];
    //coordinates of a vertical ship would be 10 points apart and 1 point apart for horizontal
    rotation == "v" ? (increment = 10) : (increment = 1);
    let initialPosition = tempGridCoord[Math.floor(Math.random() * tempGridCoord.length)];
    ship.push(initialPosition);
    let nextPosition = initialPosition;
    for (i = 1; i < length; i++) {
      nextPosition += increment;
      ship.push(nextPosition);
    }
    let found1 = ship.some((n) => righEdge.includes(n));
    let found2 = ship.some((n) => n > 89);
    let found3 = ship.some((n) => self.shipArray.includes(n));
    /* Any number found on the right hand side? if yes then generate a new array
       Any nummber found on the bottom side? if yes than generate a new array
       Any number found on the shipArray? if yes then generate a new array 
       *found3 test will be fails for the first ship
       *the or operator causing the tests to hop to the next if found false*/
    if (found1 == true || found2 == true || found3 == true) {
      self.createShip(length, rotation);
    } else {
      for (i = 0; i < ship.length; i++) {
        //when an array is generatd that isn't on the edge, the bottom or repeats 
        // it is added to the ship objects array
        self.shipArray.push(ship[i]);
      }
      return ship;
    }
  }
  isSunk(grid, index, array, score, msg) {
    let self = this;
    let val = 0;
    // all coordinates saved are in ship array and this cuts out the 
    // all the unique ships that were generated by identifying their length
    let ship1 = array.slice(0, 5);
    let ship2 = array.slice(6, 9);
    let ship3 = array.slice(10, 12);
    let ship4 = array.slice(13, 15);
    let ship5 = array.slice(-2);
    if (grid[index].textContent == "X") {
      msg.textContent = `${self.id} hit ship!`;
    } else {
      msg.textContent = `${self.id} took a shot and missed`;
    }
    ship1.every((e) => grid[e].textContent == "X") ? (val += 1) : 0;
    ship2.every((e) => grid[e].textContent == "X") ? (val += 1) : 0;
    ship3.every((e) => grid[e].textContent == "X") ? (val += 1) : 0;
    ship4.every((e) => grid[e].textContent == "X") ? (val += 1) : 0;
    ship5.every((e) => grid[e].textContent == "X") ? (val += 1) : 0;
    score.textContent = `Ships destroyed: ${val}`;
    if (
      ship1.every((e) => grid[e].textContent == "X") &&
      ship2.every((e) => grid[e].textContent == "X") &&
      ship3.every((e) => grid[e].textContent == "X") &&
      ship4.every((e) => grid[e].textContent == "X") &&
      ship5.every((e) => grid[e].textContent == "X")
    ) {
      winnerMsg.textContent = `${self.id} won!!!`;
      grid.forEach((e) => (e.style.pointerEvents = "none"));
      resetBtn.style.display = "block";
    }
  }
}
function launchGame() {
  makeGameBoard("player");
  makeGameBoard("computer");
  function restartGame() {
    main.innerHTML = "";
    btnContainer.style.display = "block";
    scorContainer.style.display = "none";
    grid2.style.display = "none";
    score1Msg.style.display = "none";
    score2Msg.style.display = "none";
    score1Msg.textContent = "Ships destroyed: 0";
    score2Msg.textContent = "Ships destroyed: 0";
    playerMsg.style.display = "none";
    computerMsg.style.display = "none";
    resetBtn.style.display = "none";
    winnerMsg.textContent = "Battleship";
    launchGame();
  }
  let gridItems1 = document.querySelectorAll(".player > div.items");
  let gridItems2 = document.querySelectorAll(".computer > div.items");
  let grid1 = document.querySelector(".player");
  let grid2 = document.querySelector(".computer");
  let modifiedGridCoord = gridCoord;
  const computer = new Ship([], [], "Computer");
  computer.createShip(5, "h");
  computer.createShip(4, "v");
  computer.createShip(3, "h");
  computer.createShip(3, "v");
  computer.createShip(2, "h");
  console.log(computer.shipArray);
  const player = new Ship([], [], "You");

  placeShipsBtn.addEventListener("click", function () {
    if (player.shipArray.length != 0) {
      player.shipArray.forEach((e) => {
        gridItems1[e].style.backgroundColor = "transparent";
      });
      player.shipArray = [];
    }
    player.createShip(5, "h");
    player.createShip(4, "v");
    player.createShip(3, "h");
    player.createShip(3, "v");
    player.createShip(2, "h");
    player.shipArray.forEach((e) => {
      gridItems1[e].style.backgroundColor = "#7d7d7d";
    });
    startGameBtn.addEventListener("click", function () {
      btnContainer.style.display = "none";
      grid2.style.display = "grid";
      score1Msg.style.display = "block";
      score2Msg.style.display = "block";
      winnerMsg.textContent = "";
      scorContainer.style.display = "flex";
    });
  });
  resetBtn.addEventListener("click", restartGame);
  gridItems2.forEach((e, i) => {
    e.addEventListener("click", function () {
      if (computer.shipArray.includes(i)) {
        player.shipsSunk.push(i);
        e.textContent = "X";
        e.style.color = "#fff";
        e.style.backgroundColor = "#40c9ff";
      } else {
        e.style.backgroundColor = "#ccc";
      }
      e.style.pointerEvents = "none";
      let compGuess =
        modifiedGridCoord[Math.floor(Math.random() * modifiedGridCoord.length)];
      modifiedGridCoord.splice(compGuess, 1);
      // if the array that houses all the players ship coordinates includes the computer guess
      if (player.shipArray.includes(compGuess)) {
        computer.shipsSunk.push(compGuess);
        gridItems1[compGuess].textContent = "X";
        gridItems1[compGuess].style.color = "#fff";
        gridItems1[compGuess].style.color = "#40c9ff";
      } else {
        gridItems1[compGuess].style.backgroundColor = "#ccc";
      }
      gridItems1[compGuess].style.pointerEvents = "none";
      player.isSunk(gridItems2, i, computer.shipArray, score2Msg, playerMsg);
      computer.isSunk(
        gridItems1,
        compGuess,
        player.shipArray,
        score1Msg,
        computerMsg
      );
    });
  });
}
launchGame();